#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, driveRight)
#pragma config(Motor,  port2,           scoopMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Avoid editing the above pragma statements directly. Use "Motor and Sensor Setup" instead

//This macro is equivalent to an array's length attribute. Divide the digital size (in bytes) of an
//array by the digital size of one of its elements to get the number of elements in the array.
#define ARRAYLENGTH(a) sizeof(a)/sizeof(a[0])

//ADD NEW SPEEDS BETWEEN CURLY BRACES BELOW, ORDERED BY MAGNITUDE
//(Remember array indices start at 0; the first item in speeds is speeds[0], not speeds[1])
const float speeds[] = {0.25,0.5,1.0,2.0};

//This variable defines which element in array speeds[] is selected first.
byte gear = 1;

/* ARM CONTROL
* If button 6 is pressed, the arm goes up or down depending on if it is
* button 6U or button 6D, respectively. Otherwise, the motor doesn't run.
*/
void armDrive() {
	if(vexRT[Btn5U] == 1)
		motor[armMotor] = 100;
	else if(vexRT[Btn5D] == 1)
		motor[armMotor] = -60;
	else
		motor[armMotor] = 30;
		//The robot needs the motor to push upward even when the user is not
		//pressing anything because the weight of the arm itself will bring it down.
}

/* GEAR CONTROL
* This part of the program changes the speed of the robot. When the button 8U is pressed, the program tests whether
* the next gear is equal to the length of array speeds[]. If so, you cant increment gear.
*/
void gearChange() {
	if(vexRT[Btn8U] == 1 && gear < ARRAYLENGTH(speeds) - 1) { // If gear is less than maximum index in speeds
		gear++;
		sleep(100);
		} else if(vexRT[Btn8D] == 1 && gear > 0) {
		gear--;
		sleep(100);
	}
}

/* LINEAR DRIVE (choose between this or POLYNOMIAL DRIVE)
* The power given to the motor is determined by the chosen value in the array speeds[] times the amount of force on
* the joystick.
*/
void linearDrive() {
	motor[leftMotor] = vexRT[Ch3]*speeds[gear];
	motor[rightMotor] = vexRT[Ch2]*speeds[gear];
}

/* POLYNOMIAL DRIVE (choose between this or LINEAR DRIVE)
 * Defines the way power is delivered to the motors based on a polynomial function. The motors receive a value depending
 * on the position of the joysticks, and is changed by coefficient c. It follows the path of a
 * third-degree polynomial that, when speeds[gear] is 1.0, intersects with y=x at (-127,-127), (0,0), and (127,127).
 * The function pow(number1,number2) means number1 to the power of number 2.
 * speeds[gear]/pow(127,2) is the coefficient of pow(vexRT[Ch3],3). See https://bit.ly/2NnOigO for visual representation.
 */
void polynomialDrive() {
	motor[leftMotor] = speeds[gear]/pow(127,2)*pow(vexRT[Ch3],3);
	motor[rightMotor] = speeds[gear]/pow(127,2)*pow(vexRT[Ch3],3);
}

/* SCOOP CONTROL
 * Defines the way the robot controls the scoop for the balls at the end of the arm.
 */
void scoopDrive() {
	if (vexRT[Btn6U] == 1) {
		motor[scoopMotor] = 30;
	} else if (vexRT[Btn6D] == 1) {
		motor[scoopMotor] = -30;
	} else {
		motor[scoopMotor] = 0;
	}
}

/* MAIN
* This function gets called repeatedly while the robot is running.
*/
task main() {
	while(true) {
		linearDrive();
		armDrive();
		scoopDrive();
		gearChange();
	}
}
