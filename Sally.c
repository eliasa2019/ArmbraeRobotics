#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port9,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Avoid editing the above pragma statements directly. Use "Motor and Sensor Setup" instead

//This macro is equivalent to an array's length attribute. Divide the digital size (in bytes) of an
//array by the digital size of one of its elements to get the number of elements in the array.
#define ARRAYSIZE(a) sizeof(a)/sizeof(a[0])
#define MAXINDEX(a) ARRAYSIZE(a) - 1

//ADD NEW SPEEDS BETWEEN CURLY BRACES BELOW, ORDERED BY MAGNITUDE FROM SMALLEST TO LARGEST WITH COMMAS IN BETWEEN
//Values must be between 0 and 1.
//(Remember array indices start at 0; the first item in speeds is speeds[0], not speeds[1])
const float speeds[] = {0.25,0.5,1};

//This variable defines which element in array speeds[] is selected.
byte gear = 2;

/* ARM CONTROL
 * If button 6 is pressed, the arm goes up or down depending on if it is
 * button 6U or button 6D, respectively. Otherwise, the motor doesn't run.
 */
void armDrive() {
		if(vexRT[Btn6U] == 1)
			motor[armMotor] = 40;
		else if(vexRT[Btn6D] == 1)
			motor[armMotor] = -40;
		else
			motor[armMotor] = -10;
}

/* GEAR CONTROL
 * This part of the program changes the speed of the robot. When the button 8U is pressed, the program tests whether
 * the next gear is equal to the length of array speeds[]. If so, you can't increment gear.
 */
void gearChange() {
		if(vexRT[Btn8U] == 1 && gear < MAXINDEX(speeds)) { // If gear is less than maximum index in speeds
			gear++;
			sleep(100);
		} else if(vexRT[Btn8D] == 1 && gear > 0) {
			gear--;
			sleep(100);
		}
}

/* LINEAR DRIVE (choose between this or POLYNOMIAL DRIVE)
 * Defines the way power is delivered to the motors. The motors receive a value from -127 to 127 depending
 * on the position of the joysticks, and is changed by coefficient c.
 */
void linearDrive() {
	motor[leftMotor] = speeds[gear]*vexRT[Ch3];
	motor[rightMotor] = speeds[gear]*vexRT[Ch2];
}

/* POLYNOMIAL DRIVE (choose between this or LINEAR DRIVE)
 * Defines the way power is delivered to the motors based on a polynomial function. Intended for sensitive maneuvering.
 * The motors receive a value depending on the position of the joysticks, and is changed by coefficient c. Visit
 * https://bit.ly/2NnOigO for visual representation, where the x-axis is how far you push the joystick and the y-axis
 * is how much power gets delivered to the motor. Linear drive is represented as a red line while polynomial drive is the
 * blue line. Move the c slider to see how the different values in speeds[] change the plot. Note how the top forward and
 * reverse speeds are the same for both, but the delivered power is lower everywhere else.
 */
void polynomialDrive() {
	motor[leftMotor] = speeds[gear]/pow(127,2)*pow(vexRT[Ch3],3);
	motor[rightMotor] = speeds[gear]/pow(127,2)*pow(vexRT[Ch3],3);
}

/* MAIN
 * This function gets called repeatedly while the robot is running.
 */
task main()
{
	while(true)
	{
		linearDrive();
		armDrive();
		gearChange();
	}
}
